datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  discordId     String  @id @unique
  minecraftUuid String? @unique
  username      String?
  discriminator String?
  accessToken   String?
  refreshToken  String?
  tokenExpires  BigInt?

  members Member[]
}

model Member {
  guildId String
  guild   Guild  @relation(fields: [guildId], references: [guildId], onDelete: Cascade)

  discordId String
  user      User   @relation(fields: [discordId], references: [discordId], onDelete: Cascade)

  openTicketChannelId       String?  @unique
  guildApplicationChannelId String?  @unique
  timeJoinedWaitlist        BigInt?
  frozenOnWaitlist          Boolean?
  informedOnWaitlist        Boolean?

  submitedChallenges SubmitedChallenge[]

  @@id([guildId, discordId])
}

model Guild {
  guildId              String   @id
  waitlistJoinMessage  String   @default("You are now on the waitlist")
  ticketRoleIds        String[]
  applicationQuestions String[]

  members            Member[]
  channels           Channel[]
  roles              Role[]
  skullboardMessages SkullboardMessage[]
  challenges         Challenge[]
}

model SkullboardMessage {
  guildId String
  guild   Guild  @relation(fields: [guildId], references: [guildId], onDelete: Cascade)

  originalMessageId   String @unique
  skullboardMessageId String @unique

  @@id([guildId, originalMessageId])
}

model Challenge {
  id      String
  guildId String

  guild       Guild  @relation(fields: [guildId], references: [guildId], onDelete: Cascade)
  displayName String
  points      Int

  submitedChallenges SubmitedChallenge[]

  @@id([id, guildId])
}

enum SubmitedChallengeState {
  APPROVED
  PENDING
}

model SubmitedChallenge {
  memberId    String
  challengeId String
  guildId     String

  state SubmitedChallengeState

  member    Member    @relation(fields: [guildId, memberId], references: [guildId, discordId], onDelete: Cascade)
  challenge Challenge @relation(fields: [guildId, challengeId], references: [guildId, id], onDelete: Cascade)

  @@id([memberId, challengeId])
}

enum RoleType {
  DISCORD_STAFF
  GUILD_STAFF
  APPLICATIONS_TEAM
  WAITLIST
}

model Role {
  roleId  String
  guildId String
  guild   Guild  @relation(fields: [guildId], references: [guildId], onDelete: Cascade)

  roleType RoleType

  @@id([roleId, guildId])
}

enum ChannelType {
  WAITLIST
  SUGGESTIONS
  GUILD_BRIDGE
  SKULLBOARD
  CHALLENGE_SUBMISSIONS
  CHALLENGE_PROOF // Where challenge accept/deny messages are sent if the user doesn't have their DMs open
}

model Channel {
  channelId String
  guildId   String
  guild     Guild  @relation(fields: [guildId], references: [guildId], onDelete: Cascade)

  channelType ChannelType

  @@id([channelId, guildId])
}
